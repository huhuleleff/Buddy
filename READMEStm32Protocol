# STM32 â†” ESP32 Multi-Drop Auto-Addressing System
## Implementation Guide & Debugging Documentation

---

## ğŸ“‹ Table of Contents
1. [System Overview](#system-overview)
2. [Hardware Wiring](#hardware-wiring)
3. [Pin Configuration](#pin-configuration)
4. [Upload Instructions](#upload-instructions)
5. [Expected Behavior](#expected-behavior)
6. [Debugging Guide](#debugging-guide)
7. [Protocol Details](#protocol-details)
8. [Troubleshooting](#troubleshooting)

---

## System Overview

This implementation provides position-aware auto-addressing for multiple STM32 slaves controlled by a single ESP32 master using only 4 wires.

### Key Features
- âœ… Automatic address assignment based on physical position
- âœ… No manual configuration required on STM32 nodes
- âœ… Built-in address verification
- âœ… Comprehensive debug output
- âœ… Visual LED indicators
- âœ… Simple 4-wire connection

### Communication Protocol
- **DATA Line**: Shared, multi-drop, software UART at 9600 baud
- **DISCOVER Line**: Daisy-chained, permission signal
- **Addressing**: Master assigns, slaves accept

---

## Hardware Wiring

### 4-Wire System

```
Power Lines:
  VCC  â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚         â”‚         â”‚         â”‚
  GND  â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         ESP32     STM32_1   STM32_2   STM32_3

Communication Lines:

1. DATA (Shared Bus - needs pull-up resistor):
   
   ESP32_GPIO21 â”€â”€â”¬â”€â”€â”€â”€ STM32_1_PA0
                  â”‚
                  â”œâ”€â”€â”€â”€ STM32_2_PA0
                  â”‚
                  â”œâ”€â”€â”€â”€ STM32_3_PA0
                  â”‚
                  â””â”€â”€â”€â”€ 4.7kÎ© â”€â”€â”€â”€ VCC (3.3V)

2. DISCOVER (Daisy Chain):

   ESP32_GPIO22 â”€â”€â†’ STM32_1_PA1 (DISCOVER_IN)
                    STM32_1_PA2 (DISCOVER_OUT) â”€â”€â†’ STM32_2_PA1
                                                    STM32_2_PA2 â”€â”€â†’ STM32_3_PA1
                                                                    STM32_3_PA2 (unused)
```

### Physical Connection Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ESP32     â”‚
â”‚   Master    â”‚
â”‚             â”‚
â”‚  GPIO21 â”€â”€â”€â”€â”¼â”€â”€â”€â”€â” DATA (with pull-up to VCC)
â”‚  GPIO22 â”€â”€â”€â”€â”¼â”€â”€â”€â”â”‚ DISCOVER
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
                  â”‚â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚   â”‚
      â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   â””â”€â†’â”‚ PA1  STM32  â”‚ Position 1
      â””â”€â”€â”€â”€â”€â†’â”‚ PA0  Slave  â”‚ (Will get Address 1)
              â”‚ PA2 â”€â”€â”€â”€â”   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”˜
                        â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â””â”€â†’â”‚ PA1  STM32  â”‚ Position 2
              â”Œâ”€â†’â”‚ PA0  Slave  â”‚ (Will get Address 2)
              â”‚  â”‚ PA2 â”€â”€â”€â”€â”   â”‚
              â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”˜
              â”‚            â”‚
              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚  â”‚
              â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  â””â”€â†’â”‚ PA1  STM32  â”‚ Position 3
              â””â”€â”€â”€â”€â†’â”‚ PA0  Slave  â”‚ (Will get Address 3)
                    â”‚ PA2         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Pin Configuration

### ESP32 Master

| Pin    | Function       | Direction | Notes                          |
|--------|----------------|-----------|--------------------------------|
| GPIO21 | DATA           | I/O       | Software UART, idle HIGH       |
| GPIO22 | DISCOVER       | Output    | Controls discovery chain       |
| GND    | Ground         | -         | Common ground                  |
| 3.3V   | Power          | -         | Power supply (or use VIN/5V)   |

### STM32 Slave (each node)

| Pin  | Function      | Direction | Notes                          |
|------|---------------|-----------|--------------------------------|
| PA0  | DATA          | I/O       | Software UART, idle HIGH       |
| PA1  | DISCOVER_IN   | Input     | From previous node/ESP32       |
| PA2  | DISCOVER_OUT  | Output    | To next node                   |
| PC13 | LED           | Output    | Status indicator (optional)    |
| GND  | Ground        | -         | Common ground                  |
| 3.3V | Power         | -         | Power supply                   |

**Important Notes:**
- All devices must share a common ground
- DATA line requires a single 4.7kÎ© pull-up resistor to VCC
- Do not add pull-up on DISCOVER lines
- Adjust pin numbers if your STM32 board differs

---

## Upload Instructions

### 1. Configure Your Hardware

Before uploading code, verify your pin assignments match your hardware:

**ESP32 (esp32_master.ino)**:
```cpp
#define DATA_PIN          21    // Adjust if needed
#define DISCOVER_PIN      22    // Adjust if needed
```

**STM32 (stm32_slave.ino)**:
```cpp
#define DATA_PIN        PA0     // Adjust if needed
#define DISCOVER_IN     PA1     // Adjust if needed
#define DISCOVER_OUT    PA2     // Adjust if needed
#define LED_PIN         PC13    // Most STM32 boards use PC13
```

### 2. Upload to ESP32

1. Open `esp32_master.ino` in Arduino IDE
2. Select your ESP32 board: **Tools â†’ Board â†’ ESP32 Dev Module**
3. Select the correct COM port: **Tools â†’ Port â†’ (your port)**
4. Click **Upload**
5. Open Serial Monitor at **115200 baud**

### 3. Upload to Each STM32

1. Open `stm32_slave.ino` in Arduino IDE
2. Select your STM32 board: **Tools â†’ Board â†’ (your STM32 board)**
3. Select upload method: **Tools â†’ Upload method â†’ (STLink/Serial/DFU)**
4. Select the correct COM port if using serial upload
5. Click **Upload**
6. Open Serial Monitor at **115200 baud** for that node
7. **Repeat for each STM32 node**

### 4. Power-Up Sequence

**IMPORTANT**: Follow this sequence:

1. **Power all STM32 nodes first**
   - Verify each shows "Waiting for discovery..." on serial monitor
   
2. **Power the ESP32 last** (or press reset)
   - ESP32 will immediately start discovery
   - Watch the serial output on all devices

---

## Expected Behavior

### On ESP32 Serial Monitor

```
========================================
ESP32 Master - Auto-Addressing System
========================================

[INIT] Pins configured:
  DATA_PIN (GPIO21): INPUT mode
  DISCOVER_PIN (GPIO22): OUTPUT mode, set LOW
  Bit period: 104 us (9600 baud)

========================================
Starting Discovery Phase
========================================

[DISCOVERY] Asserting DISCOVER line (HIGH)

--- Attempting to assign address 1 (0x01) ---
[TX] Sending discovery command for address 0x01
[TX] Command sent, waiting for ACK...
[RX] ACK received (0xA5)
[SUCCESS] Node at position 1 acknowledged address 1

--- Attempting to assign address 2 (0x02) ---
[TX] Sending discovery command for address 0x02
[TX] Command sent, waiting for ACK...
[RX] ACK received (0xA5)
[SUCCESS] Node at position 2 acknowledged address 2

--- Attempting to assign address 3 (0x03) ---
[TX] Sending discovery command for address 0x03
[TX] Command sent, waiting for ACK...
[RX] Timeout - no response
[DISCOVERY] No acknowledgment received
[DISCOVERY] Assuming no more nodes in chain

[DISCOVERY] De-asserting DISCOVER line (LOW)

========================================
Discovery Phase Complete
========================================
Total nodes discovered: 2

Discovered addresses:
  Node 1: Address 0x01 (1)
  Node 2: Address 0x02 (2)

========================================
Verifying Assigned Addresses
========================================

[VERIFY] Pinging node at address 0x01...
[OK] Node 0x01 responded correctly
[VERIFY] Pinging node at address 0x02...
[OK] Node 0x02 responded correctly

========================================
âœ“ All addresses verified successfully!
========================================
```

### On Each STM32 Serial Monitor

**STM32 Node 1 (First in chain):**
```
========================================
STM32 Slave - Auto-Addressing System
========================================

[INIT] Pin configuration:
  DATA_PIN: INPUT mode
  DISCOVER_IN: INPUT mode
  DISCOVER_OUT: OUTPUT mode, set LOW
  Bit period: 104 us (9600 baud)

[STATE] Node initialized:
  ID: UNASSIGNED (0xFF)
  assigned: false
  DISCOVER_OUT: LOW

[READY] Waiting for discovery...

[DISCOVERY] DISCOVER_IN is HIGH - listening for assignment
[RX] Packet received: CMD=0xDA, ADDR=0x01, CHK=0x8F

========================================
Processing Address Assignment
========================================
[ASSIGN] Received address: 0x01 (1)
[ASSIGN] Address accepted and stored
[STATE] ID: 0x01
[STATE] assigned: true
[TX] Sending ACK...
[TX] ACK sent
[DISCOVER] Setting DISCOVER_OUT HIGH

[SUCCESS] Address assignment complete!
========================================

[PING] Received, sending ACK
```

**STM32 Node 2 (Second in chain):**
```
[Similar output but receives address 0x02]
```

### LED Behavior

**Before Discovery:**
- All STM32 LEDs: 3 quick blinks, then OFF

**During Discovery:**
- Addressed STM32: 5 quick blinks when address received

**After Discovery:**
- Addressed STM32s: LED stays ON (solid)
- Unaddressed STM32s: LED stays OFF

**During Ping:**
- Brief flicker when pinged

---

## Debugging Guide

### Enable Verbose Debugging

The code already includes comprehensive debug output. To see timing details, you can add:

```cpp
// In receiveByte() function, add timing debug:
unsigned long start_time = micros();
DEBUG_UART.printf("[DEBUG] Waiting for start bit...\n");

// After receiving:
DEBUG_UART.printf("[DEBUG] Byte received in %lu us\n", micros() - start_time);
```

### Logic Analyzer Capture Points

If using a logic analyzer or oscilloscope:

1. **DATA Line** - Should show:
   - Idle HIGH
   - Clean UART frames at 9600 baud
   - Start bit (LOW), 8 data bits, stop bit (HIGH)

2. **DISCOVER Line** - Should show:
   - LOW at startup
   - HIGH during discovery phase
   - Stays HIGH after first node is addressed
   - Each node passes it downstream

### Expected Timing

| Event                  | Duration        |
|------------------------|-----------------|
| Bit period             | ~104 Î¼s         |
| Byte transmission      | ~1.04 ms        |
| Inter-command delay    | 50 ms           |
| ACK timeout            | 100 ms          |
| Discovery timeout/node | 500 ms          |

---

## Protocol Details

### Discovery Command Packet

```
Byte 0: Command    = 0xDA (CMD_DISCOVERY_ASSIGN)
Byte 1: Address    = 0x01, 0x02, 0x03, ... (assigned address)
Byte 2: Checksum   = (Command XOR Address) XOR 0x55
```

**Example**: Assigning address 1
```
TX: DA 01 8F
    â”‚â”‚ â”‚â”‚ â”‚â”‚
    â”‚â”‚ â”‚â”‚ â””â””â”€ Checksum: (0xDA ^ 0x01) ^ 0x55 = 0x8F
    â”‚â”‚ â””â””â”€â”€â”€ Address: 1
    â””â””â”€â”€â”€â”€â”€ Command: Discovery Assign
```

### Acknowledgment

```
RX: A5
    â””â””â”€ ACK byte
```

### Ping Command Packet

```
Byte 0: Command    = 0x50 (CMD_PING)
Byte 1: Address    = Target node address
Byte 2: Checksum   = (Command XOR Address) XOR 0x55
```

---

## Troubleshooting

### Problem: No Nodes Discovered

**Symptoms:**
```
[DISCOVERY] No acknowledgment received
Total nodes discovered: 0
```

**Checks:**
1. âœ“ Is DATA line pulled HIGH? (Measure with multimeter: should be ~3.3V)
2. âœ“ Are all grounds connected?
3. âœ“ Is DISCOVER properly daisy-chained? (ESP32 â†’ STM32_1 â†’ STM32_2)
4. âœ“ Are STM32s powered on BEFORE ESP32?
5. âœ“ Check STM32 serial monitors - are they waiting for discovery?

**Solutions:**
- Add/check 4.7kÎ© pull-up resistor on DATA line
- Verify pin numbers match your hardware
- Try powering just one STM32 first

---

### Problem: Only First Node Discovered

**Symptoms:**
```
Total nodes discovered: 1
```

**Checks:**
1. âœ“ Is STM32_1's DISCOVER_OUT (PA2) connected to STM32_2's DISCOVER_IN (PA1)?
2. âœ“ On STM32_1 serial monitor, does it show "DISCOVER_OUT: HIGH" after addressing?
3. âœ“ Are all subsequent STM32s powered?

**Solutions:**
- Check daisy-chain wiring carefully
- Verify STM32_1 is setting DISCOVER_OUT HIGH (check with multimeter)
- Ensure STM32_1 PA2 â†’ STM32_2 PA1 connection is solid

---

### Problem: Checksum Errors

**Symptoms:**
```
[ERROR] Checksum mismatch!
```

**Checks:**
1. âœ“ Are DATA line connections secure?
2. âœ“ Is DATA line too long? (Keep under 1 meter for reliability)
3. âœ“ Any electrical noise sources nearby?

**Solutions:**
- Reduce baud rate (change DATA_BAUD to 4800)
- Use shielded cable for DATA line
- Add small capacitors (100nF) near each device's power pins

---

### Problem: Intermittent Communication

**Symptoms:**
- Sometimes works, sometimes doesn't
- Random timeouts
- Nodes dropping offline

**Checks:**
1. âœ“ Power supply stability (use multimeter to check voltage under load)
2. âœ“ Loose connections?
3. âœ“ Ground loops?

**Solutions:**
- Use decoupling capacitors (100nF ceramic + 10Î¼F electrolytic per device)
- Ensure all ground connections are solid and short
- Power devices from same supply if possible
- Try lower baud rate (4800 or 2400)

---

### Problem: STM32 Not Responding After Address Assignment

**Symptoms:**
- Address assigned successfully
- Ping fails

**Checks:**
1. âœ“ STM32 serial monitor shows "assigned: true"?
2. âœ“ STM32 serial monitor shows correct ID?

**Debug:**
```cpp
// In STM32 loop(), add before if(node.assigned):
DEBUG_UART.printf("[DEBUG] assigned=%d, id=0x%02X\n", node.assigned, node.id);
```

---

## Advanced Debugging

### Measure Signal Quality

Use an oscilloscope on DATA line:
- **Good signal**: Clean square waves, sharp edges
- **Bad signal**: Rounded edges, ringing, noise

### Add Delays for Stability

If experiencing timing issues:

```cpp
// In ESP32, increase delays:
#define INTER_CMD_DELAY   100000  // 100ms instead of 50ms
#define ACK_TIMEOUT       200000  // 200ms instead of 100ms
```

### Test Individual Nodes

Power only one STM32 at a time to isolate problems:
1. Connect only STM32_1, verify it gets address 1
2. Add STM32_2, verify it gets address 2
3. Continue adding nodes one at a time

---

## Success Criteria Checklist

âœ… **Discovery Phase:**
- [ ] ESP32 shows "Discovery Phase Complete"
- [ ] ESP32 shows correct number of nodes discovered
- [ ] Each STM32 shows "Address assignment complete"
- [ ] Each STM32 has unique address
- [ ] Addresses match physical position

âœ… **Verification Phase:**
- [ ] ESP32 shows "All addresses verified successfully"
- [ ] Each STM32 responds to ping
- [ ] Each STM32 LED is solid ON

âœ… **Communication:**
- [ ] No checksum errors
- [ ] No timeouts
- [ ] Stable operation over time

---

## Next Steps

Once addressing is working reliably, you can:

1. **Add data exchange commands** (read sensor values, control outputs)
2. **Implement error recovery** (node reset detection, re-discovery)
3. **Optimize timing** (faster baud rates, shorter timeouts)
4. **Add features** (broadcast commands, node health monitoring)

---

## Quick Reference: Important Variables

| Variable         | Location | Meaning                          |
|------------------|----------|----------------------------------|
| `discovered_nodes` | ESP32  | Total nodes found                |
| `node.id`        | STM32    | Assigned address (or 0xFF)       |
| `node.assigned`  | STM32    | true after address received      |
| `DISCOVER_OUT`   | STM32    | LOW = not ready, HIGH = ready    |

---

## Contact & Support

For issues or questions:
1. Check serial monitors on ALL devices
2. Verify wiring against diagrams
3. Try with single node first
4. Check power supply voltage/current

**Common gotchas:**
- Forgot pull-up resistor on DATA
- Wrong pin numbers for your board  
- STM32s not powered before ESP32
- Ground not connected

Good luck with your implementation! ğŸš€
