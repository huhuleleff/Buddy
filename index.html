<!DOCTYPE html>



<html>



<head>



    <meta charset="UTF-8">



    <meta name="viewport" content="width=device-width, initial-scale=1.0">



    <title>ESP32 Grow Buddy</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>



    <style>



        body {

            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;

            margin: 0;

            padding: 60px 20px 20px; /* Added padding-top for button spacing */

            background: #303030; /* Even darker gray background */

            color: #f3f4f6; /* Light gray text */

            min-height: 100vh;

        }



        



        .main-data-container {

            background: radial-gradient(circle at center, rgba(38, 38, 38, 0.95) 0%, rgba(26, 26, 26, 0.95) 65%, rgba(18, 18, 18, 0.95) 100%);

            border-radius: 30px; /* Even more rounded corners */

            position: relative;

            padding: 60px;

            box-shadow: 0 8px 32px rgba(0,0,0,0.4); /* Enhanced drop shadow */

            max-width: 800px; /* Shorter width */

            margin: 0 auto 30px;

            backdrop-filter: blur(10px);

            min-height: 400px;

        }

        .main-data-container h2 {

            color: #f3f4f6;

            text-align: center;

            margin: 0 0 25px 0;

            font-size: 1.5em;

            font-weight: 300;

        }

        .data-row {

            display: flex;

            justify-content: space-around;

            flex-wrap: wrap;

            gap: 30px;

            margin-bottom: 20px;

        }

        .data-item {

            text-align: center;

            flex: 1;

            min-width: 150px;

        }

        .data-label {

            color: #9ca3af;

            font-size: 0.9em;

            margin-bottom: 8px;

            font-weight: 500;

        }

        .data-value {

            font-size: 2.2em;

            font-weight: 300;

            color: #f9fafb;

            margin: 0;

        }

        .temp-line {

            display: inline-flex;

            align-items: baseline;

            gap: 10px;

        }

        .temp-trend-inline {

            font-size: 0.6em;

            font-weight: 700;

            line-height: 1;

            position: relative;

            top: -4px;

            margin-top: 0;

        }

        .data-trend {

            font-size: 0.8em;

            margin-top: 5px;

        }

        .data-extremes {

            font-size: 0.75em;

            color: #9ca3af;

            margin-top: 3px;

        }



        




        /* Dropdown Tab Styles */
        .dropdown-tab {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .dropdown-btn {
            background: #2d2d2d;
            color: #f3f4f6;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dropdown-btn:hover {
            background: #3d3d3d;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(26, 26, 26, 0.95);
            min-width: 350px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            margin-top: 5px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-header {
            padding: 15px 20px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #f3f4f6;
            font-weight: 500;
            font-size: 14px;
        }

        .dropdown-body {
            padding: 20px;
        }

        .dropdown-footer {
            padding: 15px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Simple proportional scaling for mobile */
        @media (max-width: 768px) {
            body {
                transform: scale(0.8);
                transform-origin: top left;
                width: 125%; /* Compensate for scaling */
            }
        }
        
        @media (max-width: 480px) {
            body {
                transform: scale(0.6);
                width: 167%; /* Compensate for scaling */
            }
        }



    </style>



</head>



<body>




    <!-- Discord Settings Dropdown Tab -->
    <div class="dropdown-tab">
        <button class="dropdown-btn" onclick="toggleDropdown()">
            <span>üì±</span>
            <span>Discord</span>
            <span id="dropdownArrow">‚ñº</span>
        </button>
        <div id="discordDropdown" class="dropdown-content">
            <div class="dropdown-header">Discord Webhook Nastavitve</div>
            <div class="dropdown-body">
                <label for="webhookUrlInput" style="color: #f3f4f6; display: block; margin-bottom: 8px; font-weight: 500;">Webhook URL:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <input type="password" id="webhookUrlInput" placeholder="Vnesite Discord webhook URL" 
                           style="flex: 1; padding: 10px; border: 1px solid #4a5568; border-radius: 6px; 
                                  background: rgba(45, 45, 45, 0.8); color: #f3f4f6; font-size: 14px;">
                    <button onclick="toggleTokenVisibility()" id="toggleVisibilityBtn"
                            style="padding: 10px 15px; background: #4a5568; color: #f3f4f6; border: none; 
                                   border-radius: 6px; cursor: pointer; font-size: 12px;">
                        üëÅÔ∏è
                    </button>
                </div>
                <div id="tokenStatus" style="margin-bottom: 15px; font-size: 12px; color: #9ca3af;"></div>
            </div>
            <div class="dropdown-footer">
                <button onclick="loadDiscordWebhook()" 
                        style="padding: 8px 16px; background: #4a5568; color: #f3f4f6; border: none; 
                               border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Osve≈æi
                </button>
                <button onclick="saveDiscordWebhook()" 
                        style="padding: 8px 16px; background: #374151; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Shrani
                </button>
            </div>
        </div>
    </div>

    

                <div class="main-data-container">
        <div style="position: absolute; left: 60px; top: 80px;">
            <div class="temp-line">
                <div class="data-value" id="temperature" style="font-size: 5.6em; font-weight: 100; font-family: system-ui, sans-serif;">0.0 <span style="font-size: 0.18em;"><span style="font-size: 2.0em;">¬∞</span><span style="position: relative; top: -3px; font-weight: 200; font-size: 2.5em; font-family: 'Helvetica Neue', Arial, sans-serif;">C</span></span></div>
                <div style="display: flex; flex-direction: column; height: 5.6em; margin-left: 5px; position: relative; top: -3.2em;">
                    <div style="font-size: 0.6em; color: #ef4444;"><span id="tempMax">--</span>¬∞C</div>
                    <div style="font-size: 0.6em; color: #3b82f6; margin-top: 0.5em;"><span id="tempMin">--</span>¬∞C</div>
                    <div class="data-trend temp-trend-inline" id="tempTrend" style="color: #9ca3af; margin-top: 1em; font-size: 1.0em; margin-left: 0.5em;"></div>
                </div>
            </div>
            <div id="growStatus" style="position: absolute; top: 130px; left: 0px; font-size: 1.0em; color: #10b981; font-weight: 500;">--</div>
            <div style="position: absolute; top: 160px; left: 0px; display: flex; gap: 30px; align-items: flex-start;">
                <div>
                    <div class="data-value" id="humidity" style="font-size: 1.5em !important; white-space: nowrap;">0.0 %<span id="humidityTrend" style="font-size: 1.2em; color: #9ca3af; margin-left: 0.3em;"></span></div>
                    <div class="data-extremes" style="font-size: 0.6em; color: #9ca3af;">
                        <span id="humidityMax" style="color: #ef4444;">--</span>% | 
                        <span id="humidityMin" style="color: #3b82f6;">--</span>%
                    </div>
                </div>
                <div>
                    <div class="data-value" id="pressure" style="font-size: 1.5em !important; white-space: nowrap;">0.0 hPa</div>
                </div>
            </div>
        </div>
        <!-- Soil Sensor Vertical Card -->
        <div style="position: absolute; right: 60px; top: 80px; width: 140px; height: 220px;">
            <div style="background: transparent; border-radius: 15px; padding: 15px; border: 1px solid rgba(255, 255, 255, 0.2); height: 100%; display: flex; flex-direction: column;">
                <div style="color: #9ca3af; font-size: 0.6em; margin-bottom: 12px; text-align: center; font-weight: 500;">VLA≈ΩNOST ZEMLJE</div>
                <div style="display: flex; flex-direction: column; gap: 8px; flex: 1;">
                    <div class="data-value" id="soilMoistureDisplay" style="font-size: 1.0em; text-align: center; line-height: 1.4;">--</div>
                    <div class="data-extremes" id="sensorCount" style="font-size: 0.6em; text-align: center; margin-top: auto;">Zaznani: 0</div>
                </div>
            </div>
        </div>
        
        <!-- Mini Temperature Graph -->
        <div style="position: absolute; bottom: 65px; left: 60px; right: 160px; height: 63px;">
            <div style="position: relative; width: 100%; height: 100%;">
                <canvas id="miniTempChart" style="width: 100%; height: 100%;"></canvas>
                <div id="hourlyLabels" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                <div id="hourLabels" style="position: absolute; bottom: -10px; left: 0; width: 100%; height: 20px; pointer-events: none;"></div>
            </div>
            <!-- Navigation Arrows -->
            <button onclick="scrollMiniGraph('left')" style="position: absolute; bottom: 0; left: -25px; background: none; border: none; cursor: pointer; padding: 2px; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 18l-6-6 6-6"></path>
                </svg>
            </button>
            <button onclick="scrollMiniGraph('right')" style="position: absolute; bottom: 0; right: -25px; background: none; border: none; cursor: pointer; padding: 2px; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6b7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 18l6-6-6-6"></path>
                </svg>
            </button>
            <!-- Graph Icon Link -->
            <a href="graphs.html" style="position: fixed; bottom: 50px; right: 20px; color: #6b7280; cursor: pointer; font-size: 11px; text-decoration: none; display: flex; align-items: center; gap: 4px; transition: color 0.2s ease; z-index: 100;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="4" height="18" rx="1"></rect>
                    <rect x="10" y="8" width="4" height="13" rx="1"></rect>
                    <rect x="17" y="13" width="4" height="8" rx="1"></rect>
                </svg>
                <span style="font-weight: 400;">GRAFI</span>
            </a>
            <!-- Connection Icon Link -->
            <a href="/manager" id="openPageBtn" style="position: fixed; bottom: 35px; right: 20px; color: #6b7280; cursor: pointer; font-size: 11px; text-decoration: none; display: flex; align-items: center; gap: 4px; transition: color 0.2s ease; z-index: 100;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                    <path d="M1.42 9a16 16 0 0 1 21.16 0"></path>
                    <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                    <line x1="12" y1="20" x2="12.01" y2="20"></line>
                </svg>
                <span style="font-weight: 400;">POVEZAVA</span>
            </a>
            <!-- Files Icon Link -->
            <a href="/nadzornikprostora" id="nadzornikBtn" style="position: fixed; bottom: 20px; right: 20px; color: #6b7280; cursor: pointer; font-size: 11px; text-decoration: none; display: flex; align-items: center; gap: 4px; transition: color 0.2s ease; z-index: 100;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14,2 14,8 20,8"></polyline>
                    <line x1="16" y1="13" x2="8" y2="13"></line>
                    <line x1="16" y1="17" x2="8" y2="17"></line>
                    <polyline points="10,9 9,9 8,9"></polyline>
                </svg>
                <span style="font-weight: 400;">DATOTEKE</span>
            </a>
        </div>
    </div>










    



    <script>



        // WebSocket connection for real-time updates



        let socket;



        let reconnectAttempts = 0;



        const maxReconnectAttempts = 5;



        



        function connectWebSocket() {



            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';



            const wsUrl = `${protocol}//${window.location.host}/ws`;



            



            socket = new WebSocket(wsUrl);



            



            socket.onopen = function(event) {



                reconnectAttempts = 0;



            };



            



            socket.onmessage = function(event) {



                try {



                    if (!event.data || event.data.trim() === '') {



                        return;



                    }



                    



                    const data = JSON.parse(event.data);



                    



                    if (!data.hasOwnProperty('temperature') || !data.hasOwnProperty('humidity')) {



                        return;



                    }



                    



                    updateSensorDisplay(data);



                    



                } catch (error) {



                    // Silently handle parsing errors



                }



            };



            



            socket.onclose = function(event) {



                if (reconnectAttempts < maxReconnectAttempts) {



                    reconnectAttempts++;



                    setTimeout(connectWebSocket, 2000);



                }



            };



            



            socket.onerror = function(error) {



                // Silently handle errors



            };



        }



        



        function updateSensorDisplay(data) 



        {

            // Update temperature

            document.getElementById('temperature').innerHTML = 

                data.temperature.toFixed(1) + '<span style="font-size: 0.18em;"><span style="font-size: 2.0em; position: relative; top: -40px;">¬∞</span><span style="position: relative; top: -40px; left: -2px; font-weight: 200; font-size: 1.0em; font-family: \'Helvetica Neue\', Arial, sans-serif;">C</span></span>';

            

            // Update grow status

            if (data.growStatus) {

                document.getElementById('growStatus').textContent = data.growStatus;

            }

            

            // Update humidity
            document.getElementById('humidity').innerHTML = 
                data.humidity.toFixed(2) + ' %<span id="humidityTrend" style="font-size: 0.8em; color: #9ca3af; margin-left: 0.3em;"></span>';



            



            // Update pressure



            document.getElementById('pressure').innerHTML = 



                data.pressure.toFixed(1) + ' hPa';



            



            // Update soil moisture sensors



            updateSoilSensors(data);



            



            document.getElementById('tempMax').textContent = 



                data.tempMax.toFixed(1);



            document.getElementById('tempMin').textContent = 



                data.tempMin.toFixed(1);



            



            document.getElementById('humidityMax').textContent = 



                data.humidityMax.toFixed(1);



            document.getElementById('humidityMin').textContent = 



                data.humidityMin.toFixed(1);



            



            var tempTrendElement = document.getElementById('tempTrend');



            if (data.tempRising) {



                tempTrendElement.textContent = '‚Üë';



                tempTrendElement.style.color = '#ef4444';



            } else if (data.tempFalling) {



                tempTrendElement.textContent = '‚Üì';



                tempTrendElement.style.color = '#3b82f6';



            } else 



            {

                tempTrendElement.textContent = '‚Äî';



                tempTrendElement.style.color = '#9ca3af';



            }



            



            var humidityTrendElement = document.getElementById('humidityTrend');



            if (data.humidityRising) 



            {

                humidityTrendElement.textContent = '‚Üë';



                humidityTrendElement.style.color = '#ef4444';



            } else if (data.humidityFalling) 



            {

                humidityTrendElement.textContent = '‚Üì';



                humidityTrendElement.style.color = '#3b82f6';



            } else 



            {

                humidityTrendElement.textContent = '‚Äî';
                humidityTrendElement.style.fontSize = '0.6em';



                humidityTrendElement.style.color = '#9ca3af';



            }



        }



        



        function updateSoilSensors(data) 



        {

            const displayElement = document.getElementById('soilMoistureDisplay');

            const countElement = document.getElementById('sensorCount');

            

            const soilSensors = [];

            

            // Collect soil sensors dynamically based on discovered sensors

            const maxSensors = data.discoveredSensors || 0;

            for (let i = 1; i <= maxSensors; i++) 



            {

                const sensorKey = `zemlja${i}`;

                if (data[sensorKey] !== undefined && data[sensorKey] !== null) 



                {

                    soilSensors.push({ id: i, value: data[sensorKey] });

                }

            }

            

            // Update sensor count with actual discovered nodes

            countElement.textContent = `Zaznani senzorji: ${data.discoveredSensors || 0}`;

            

            // Create sensor display with compact Z1:XX% format

            if (soilSensors.length > 0) 



            {

                const sensorTexts = soilSensors.map(sensor => `${sensor.id}.&nbsp;&nbsp;${sensor.value.toFixed(1)}%`);
                displayElement.innerHTML = sensorTexts.join('<br>');

            } else 



            {

                displayElement.textContent = '--';

            }

        }














        // Sensor data update function (fallback - WebSocket provides real-time updates)



        function updateSensorData() {



            var xhr = new XMLHttpRequest();



            xhr.onreadystatechange = function() {



                if (this.readyState === 4 && this.status === 200) {



                    var data = JSON.parse(this.responseText);



                    updateSensorDisplay(data);



                }



            };



            xhr.open("GET", "/data", true);



            xhr.send();



            setTimeout(updateSensorData, 60000); // Update every 60 seconds as fallback



        }



        



        // Initialize WebSocket connection and start fallback updates



        function initializeDataUpdates() {



            connectWebSocket();



            updateSensorData(); // Start fallback updates



        }



        initializeDataUpdates(); // Initial call to start the update loop







        // Temperature Chart functionality with single day navigation



        let temperatureChart = null;

        let miniTempChart = null;

        let miniChartOffset = 0;

        let miniChartData = null; // Separate data storage for mini chart

        let currentIndex = 0;



        let maxIndex = 364;



        let hasReachedNoData = false; // Track if we've hit no data boundary







        // Find the latest valid date index



        function findLatestValidIndex() {



            // Fetch the actual current index from the ESP32



            return fetch('/api/currentIndex')



                .then(response => response.json())



                .then(data => {



                    // indeksvzorca is the count of days, so subtract 1 for zero-based index



                    return Math.max(0, data.currentIndex - 1);



                })



                .catch(error => {



                    console.error('Error getting current index:', error);



                    return 364; // Fallback to most recent day



                });



        }







        // Load single day data



        function loadDayData(index) {



            fetch(`/api/dayData?index=${index}`)



                .then(response => {



                    if (!response.ok) {



                        if (response.status === 400) {



                            // Check if it's "No Data" or other error



                            return response.text().then(text => {



                                if (text === "No Data") {



                                    throw new Error('No Data');



                                } else {



                                    throw new Error('Invalid index or no data');



                                }



                            });



                        }



                        throw new Error('Invalid index or no data');



                    }



                    return response.json();



                })



                .then(data => {



                    const ctx = document.getElementById('temperatureChart').getContext('2d');



                    



                    // Create or update chart



                    if (!temperatureChart) {



                        temperatureChart = new Chart(ctx, {



                            type: 'line',



                            data: {



                                labels: data.hours,



                                datasets: [



                                    {



                                        label: 'Temperatura (¬∞C)',



                                        data: data.temps,



                                        borderColor: '#ff4444',



                                        backgroundColor: 'rgba(255, 68, 68, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y'



                                    },



                                    {



                                        label: 'Vla≈ænost Zraka (%)',



                                        data: data.humidity,



                                        borderColor: '#4444ff',



                                        backgroundColor: 'rgba(68, 68, 255, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1'



                                    },



                                    {



                                        label: 'Vla≈ænost Zemlje 1 (%)',



                                        data: data.soilMoisture1,



                                        borderColor: '#4CAF50',



                                        backgroundColor: 'rgba(76, 175, 80, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Vla≈ænost Zemlje 2 (%)',



                                        data: data.soilMoisture2,



                                        borderColor: '#FF9800',



                                        backgroundColor: 'rgba(255, 152, 0, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Vla≈ænost Zemlje 3 (%)',



                                        data: data.soilMoisture3,



                                        borderColor: '#9C27B0',



                                        backgroundColor: 'rgba(156, 39, 176, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Vla≈ænost Zemlje 4 (%)',



                                        data: data.soilMoisture4,



                                        borderColor: '#00BCD4',



                                        backgroundColor: 'rgba(0, 188, 212, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    }



                                ]



                            },



                            options: {



                                responsive: true,



                                maintainAspectRatio: false,



                                interaction: {



                                    intersect: false,



                                    mode: 'index'



                                },



                                plugins: {



                                    legend: {



                                        display: false  // Hide default legend, using custom checkboxes



                                    },



                                    title: {



                                        display: true,



                                        text: '${data.date}',



                                        color: '#f3f4f6',



                                        font: {



                                            size: 14,



                                            weight: 'normal'



                                        },



                                        padding: 15



                                    },



                                    tooltip: {



                                        callbacks: {



                                            title: function(context) {



                                                return `Ura: ${context[0].label}`;



                                            },



                                            label: function(context) {



                                                if (context.dataset.yAxisID === 'y') {



                                                    return `Temperatura: ${context.parsed.y.toFixed(1)}¬∞C`;



                                                } else {



                                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;



                                                }



                                            }



                                        }



                                    }



                                },



                                scales: {



                                    x: {



                                        title: {



                                            display: true,



                                            text: 'Ura dneva',



                                            color: '#d1d5db'



                                        },



                                        ticks: {



                                            color: '#d1d5db',



                                            maxRotation: 45,



                                            minRotation: 45



                                        },



                                        grid: {



                                            color: '#2d2d2d',



                                            drawBorder: false



                                        }



                                    },



                                    y: {



                                        type: 'linear',



                                        position: 'left',



                                        title: {



                                            display: true,



                                            text: 'Temperatura (¬∞C)',



                                            color: '#d1d5db'



                                        },



                                        min: 0,



                                        max: 40,



                                        ticks: {



                                            color: '#d1d5db',



                                            stepSize: 2,



                                            callback: function(value) {



                                                return value + '¬∞C';



                                            }



                                        },



                                        grid: {



                                            color: '#2d2d2d',



                                            drawBorder: false



                                        }



                                    },



                                    y1: {



                                        type: 'linear',



                                        position: 'right',



                                        title: {



                                            display: true,



                                            text: 'Vla≈ænost Zraka & Vla≈ænost Zemlje (%)',



                                            color: '#d1d5db'



                                        },



                                        min: 0,



                                        max: 100,



                                        ticks: {



                                            color: '#d1d5db',



                                            stepSize: 2,



                                            callback: function(value) {



                                                return value + '%';



                                            }



                                        },



                                        grid: {



                                            display: false,



                                            drawBorder: false



                                        }



                                    }



                                }



                            }



                        });



                    } else {



                        // Update existing chart



                        temperatureChart.data.labels = data.hours;



                        temperatureChart.data.datasets[0].data = data.temps;



                        temperatureChart.data.datasets[1].data = data.humidity;



                        temperatureChart.data.datasets[2].data = data.soilMoisture1;



                        temperatureChart.data.datasets[3].data = data.soilMoisture2;



                        temperatureChart.data.datasets[4].data = data.soilMoisture3;



                        temperatureChart.data.datasets[5].data = data.soilMoisture4;



                        temperatureChart.options.plugins.title.text = `${data.date}`;



                        temperatureChart.update();



                        // Initialize or update mini temperature chart
                        fetchMiniChartData();



                    }



                    



                    // Update date display and button states



                    updateDateDisplay(data.date, index);



                    updateButtonStates();



                })



                .catch(error => {



                    console.error('Error loading day data:', error);



                    if (error.message === 'No Data') {



                        document.getElementById('currentDateDisplay').textContent = 'Podatki niso na voljo';



                        hasReachedNoData = true; // Mark that we've hit the boundary



                    } else {



                        document.getElementById('currentDateDisplay').textContent = 'Napaka pri nalaganju podatkov';



                    }



                    



                    // Update button states after error



                    updateButtonStates();



                });



        }







        // Update date display element



        function updateDateDisplay(date, index) {



            const position = `${index + 1}/365`;



            document.getElementById('currentDateDisplay').textContent = `${date} (${position})`;



        }







        // Update button states based on current index and data boundaries



        function updateButtonStates() {



            const prevBtn = document.getElementById('prevDay');



            const nextBtn = document.getElementById('nextDay');



            



            // Disable previous button if at index 0



            prevBtn.disabled = currentIndex <= 0;



            prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';



            prevBtn.style.cursor = prevBtn.disabled ? 'not-allowed' : 'pointer';



            



            // Disable next button if we've hit no data boundary



            nextBtn.disabled = hasReachedNoData;



            nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';



            nextBtn.style.cursor = nextBtn.disabled ? 'not-allowed' : 'pointer';



        }







        // Event listeners



        document.addEventListener('DOMContentLoaded', function() {



            // Add toggle functionality for buttons



            function setupToggleButton(buttonId, datasetIndex) {



                const button = document.getElementById(buttonId);



                button.addEventListener('click', function() {



                    if (temperatureChart) {



                        const isActive = this.classList.contains('active');



                        



                        if (isActive) {



                            // Deactivate



                            this.classList.remove('active');



                            this.classList.add('inactive');



                            temperatureChart.data.datasets[datasetIndex].hidden = true;



                        } else {



                            // Activate



                            this.classList.remove('inactive');



                            this.classList.add('active');



                            temperatureChart.data.datasets[datasetIndex].hidden = false;



                        }



                        



                        temperatureChart.update();



                    }



                });



            }



            



            // Setup all toggle buttons



            setupToggleButton('toggle-temp', 0);



            setupToggleButton('toggle-humidity', 1);



            setupToggleButton('toggle-soil1', 2);



            setupToggleButton('toggle-soil2', 3);



            setupToggleButton('toggle-soil3', 4);



            setupToggleButton('toggle-soil4', 5);



            



            // Initialize with latest valid data - FAST LOADING



            findLatestValidIndex().then(index => {



                currentIndex = index;



                loadDayData(currentIndex);



            });



            



            // Previous day button



            document.getElementById('prevDay').addEventListener('click', function() {



                if (currentIndex > 0) {



                    currentIndex--;



                    hasReachedNoData = false; // Reset boundary flag when going back



                    loadDayData(currentIndex);



                }



            });



            



            // Next day button



            document.getElementById('nextDay').addEventListener('click', function() {



                if (!hasReachedNoData) {



                    currentIndex++;



                    loadDayData(currentIndex);



                }



            });



        });







        // Monthly Chart functionality



        let monthlyChart = null;



        let currentMonth = new Date().getMonth() + 1; // JavaScript months are 0-11, we want 1-12



        let currentYear = new Date().getFullYear();







        // Month names in Slovene



        const monthNames = ['Januar', 'Februar', 'Marec', 'April', 'Maj', 'Junij', 



                           'Julij', 'Avgust', 'September', 'Oktober', 'November', 'December'];







        // Load monthly data



        function loadMonthlyData(month, year) {



            console.log(`[MONTHLY JS] Loading data for month: ${month}, year: ${year}`);



            



            fetch(`/api/monthlyData?month=${month}&year=${year}`)



                .then(response => {



                    console.log(`[MONTHLY JS] Response status: ${response.status}`);



                    if (!response.ok) {



                        console.log(`[MONTHLY JS] Response not OK, status: ${response.status}`);



                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);



                    }



                    return response.json();



                })



                .then(data => {



                    console.log(`[MONTHLY JS] Received data:`, data);



                    console.log(`[MONTHLY JS] Number of days: ${data.days ? data.days.length : 0}`);



                    



                    const ctx = document.getElementById('monthlyChart').getContext('2d');



                    



                    // Prepare data arrays



                    const dayLabels = [];



                    const avgTempData = [];



                    const avgHumidityData = [];



                    const maxTempData = [];



                    const minTempData = [];



                    const minSoil1Data = [];



                    const minSoil2Data = [];



                    const minSoil3Data = [];



                    const minSoil4Data = [];



                    



                    if (data.days && Array.isArray(data.days)) {



                        data.days.forEach(day => {



                            dayLabels.push(day.day);



                            avgTempData.push(day.avgTemp);



                            avgHumidityData.push(day.avgHumidity);



                            maxTempData.push(day.maxTemp);



                            minTempData.push(day.minTemp);



                            minSoil1Data.push(day.minSoil1);



                            minSoil2Data.push(day.minSoil2);



                            minSoil3Data.push(day.minSoil3);



                            minSoil4Data.push(day.minSoil4);



                        });



                    }



                    



                    // Create or update chart



                    if (!monthlyChart) {



                        // Store the current month and year in the chart's scope for tooltip



                        const chartMonth = month;



                        const chartYear = year;



                        monthlyChart = new Chart(ctx, {



                            type: 'line',



                            data: {



                                labels: dayLabels,



                                datasets: [



                                    {



                                        label: 'Povpreƒçna Temperatura (¬∞C)',



                                        data: avgTempData,



                                        borderColor: '#ff4444',



                                        backgroundColor: 'rgba(255, 68, 68, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 3,



                                        pointHoverRadius: 5,



                                        spanGaps: false,



                                        yAxisID: 'y',



                                        hidden: true



                                    },



                                    {



                                        label: 'Povpreƒçna Vla≈ænost (%)',



                                        data: avgHumidityData,



                                        borderColor: '#4444ff',



                                        backgroundColor: 'rgba(68, 68, 255, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 3,



                                        pointHoverRadius: 5,



                                        spanGaps: false,



                                        yAxisID: 'y1'



                                    },



                                    {



                                        label: 'Maksimalna Temperatura (¬∞C)',



                                        data: maxTempData,



                                        borderColor: '#ff6b6b',



                                        backgroundColor: 'rgba(255, 107, 107, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y'



                                    },



                                    {



                                        label: 'Minimalna Temperatura (¬∞C)',



                                        data: minTempData,



                                        borderColor: '#4dabf7',



                                        backgroundColor: 'rgba(77, 171, 247, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y'



                                    },



                                    {



                                        label: 'Min Vla≈æ. tla 1 (%)',



                                        data: minSoil1Data,



                                        borderColor: '#4CAF50',



                                        backgroundColor: 'rgba(76, 175, 80, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Min Vla≈æ. tla 2 (%)',



                                        data: minSoil2Data,



                                        borderColor: '#FF9800',



                                        backgroundColor: 'rgba(255, 152, 0, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Min Vla≈æ. tla 3 (%)',



                                        data: minSoil3Data,



                                        borderColor: '#9C27B0',



                                        backgroundColor: 'rgba(156, 39, 176, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    },



                                    {



                                        label: 'Min Vla≈æ. tla 4 (%)',



                                        data: minSoil4Data,



                                        borderColor: '#00BCD4',



                                        backgroundColor: 'rgba(0, 188, 212, 0.1)',



                                        fill: false,



                                        tension: 0.4,



                                        pointRadius: 2,



                                        pointHoverRadius: 4,



                                        spanGaps: false,



                                        yAxisID: 'y1',



                                        hidden: true



                                    }



                                ]



                            },



                            options: {



                                responsive: true,



                                maintainAspectRatio: false,



                                interaction: {



                                    intersect: false,



                                    mode: 'index'



                                },



                                plugins: {



                                    legend: {



                                        display: false  // Hide default legend, using custom toggle buttons



                                    },



                                    title: {



                                        display: true,



                                        text: `${monthNames[month - 1]} ${year}`,



                                        color: '#f3f4f6',



                                        font: {



                                            size: 14,



                                            weight: 'normal'



                                        },



                                        padding: 15



                                    },



                                    tooltip: {



                                        callbacks: {



                                            title: function(context) {



                                                return `Dan: ${context[0].label}. ${monthNames[chartMonth - 1]} ${chartYear}`;



                                            },



                                            label: function(context) {



                                                if (context.dataset.yAxisID === 'y') {



                                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}¬∞C`;



                                                } else {



                                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;



                                                }



                                            }



                                        }



                                    }



                                },



                                scales: {



                                    x: {



                                        title: {



                                            display: true,



                                            text: 'Dan v mesecu',



                                            color: '#d1d5db'



                                        },



                                        ticks: {



                                            color: '#d1d5db',



                                            maxRotation: 45,



                                            minRotation: 45



                                        },



                                        grid: {



                                            color: '#2d2d2d',



                                            drawBorder: false



                                        }



                                    },



                                    y: {



                                        type: 'linear',



                                        position: 'left',



                                        title: {



                                            display: true,



                                            text: 'Temperatura (¬∞C)',



                                            color: '#d1d5db'



                                        },



                                        min: 0,



                                        max: 40,



                                        ticks: {



                                            color: '#d1d5db',



                                            stepSize: 2,



                                            callback: function(value) {



                                                return value + '¬∞C';



                                            }



                                        },



                                        grid: {



                                            color: '#2d2d2d',



                                            drawBorder: false



                                        }



                                    },



                                    y1: {



                                        type: 'linear',



                                        position: 'right',



                                        title: {



                                            display: true,



                                            text: 'Vla≈ænost (%)',



                                            color: '#d1d5db'



                                        },



                                        min: 0,



                                        max: 100,



                                        ticks: {



                                            color: '#d1d5db',



                                            stepSize: 2,



                                            callback: function(value) {



                                                return value + '%';



                                            }



                                        },



                                        grid: {



                                            display: false,



                                            drawBorder: false



                                        }



                                    }



                                }



                            }



                        });



                    } else {

                        // Update existing chart

                        monthlyChart.data.labels = dayLabels;

                        monthlyChart.data.datasets[0].data = avgTempData;

                        monthlyChart.data.datasets[1].data = avgHumidityData;

                        monthlyChart.data.datasets[2].data = maxTempData;

                        monthlyChart.data.datasets[3].data = minTempData;

                        monthlyChart.data.datasets[4].data = minSoil1Data;

                        monthlyChart.data.datasets[5].data = minSoil2Data;

                        monthlyChart.data.datasets[6].data = minSoil3Data;

                        monthlyChart.data.datasets[7].data = minSoil4Data;

                        

                        // Update title and tooltip with new month/year

                        monthlyChart.options.plugins.title.text = `${monthNames[month - 1]} ${year}`;

                        monthlyChart.options.plugins.tooltip.callbacks.title = function(context) {

                            return `Dan: ${context[0].label}. ${monthNames[month - 1]} ${year}`;

                        };

                        

                        monthlyChart.update();

                    }



                    



                    // Update month display



                    updateMonthDisplay(month, year);



                    console.log('[MONTHLY JS] Successfully loaded monthly data');



                })



                .catch(error => {



                    console.error('[MONTHLY JS] Error loading monthly data:', error);



                    console.error('[MONTHLY JS] Error details:', error.message);



                    console.error('[MONTHLY JS] Error stack:', error.stack);



                    document.getElementById('currentMonthDisplay').textContent = `Napaka: ${error.message}`;



                });



        }







        // Update month display element



        function updateMonthDisplay(month, year) {



            document.getElementById('currentMonthDisplay').textContent = `${monthNames[month - 1]} ${year}`;



        }







        // Event listeners for monthly chart



        document.addEventListener('DOMContentLoaded', function() {



            // Setup monthly toggle buttons



            function setupMonthlyToggleButton(buttonId, datasetIndex) {



                const button = document.getElementById(buttonId);



                button.addEventListener('click', function() {



                    if (monthlyChart) {



                        const isActive = this.classList.contains('active');



                        



                        if (isActive) {



                            // Deactivate



                            this.classList.remove('active');



                            this.classList.add('inactive');



                            monthlyChart.data.datasets[datasetIndex].hidden = true;



                        } else {



                            // Activate



                            this.classList.remove('inactive');



                            this.classList.add('active');



                            monthlyChart.data.datasets[datasetIndex].hidden = false;



                        }



                        



                        monthlyChart.update();



                    }



                });



            }



            



            // Setup all monthly toggle buttons



            setupMonthlyToggleButton('monthly-toggle-avgtemp', 0);



            setupMonthlyToggleButton('monthly-toggle-avghumidity', 1);



            setupMonthlyToggleButton('monthly-toggle-maxtemp', 2);



            setupMonthlyToggleButton('monthly-toggle-mintemp', 3);



            setupMonthlyToggleButton('monthly-toggle-minsoil1', 4);



            setupMonthlyToggleButton('monthly-toggle-minsoil2', 5);



            setupMonthlyToggleButton('monthly-toggle-minsoil3', 6);



            setupMonthlyToggleButton('monthly-toggle-minsoil4', 7);



            



            // Initialize with current month data



            loadMonthlyData(currentMonth, currentYear);



            



            // Previous month button



            document.getElementById('prevMonth').addEventListener('click', function() {



                currentMonth--;



                if (currentMonth < 1) {



                    currentMonth = 12;



                    currentYear--;



                }



                loadMonthlyData(currentMonth, currentYear);



            });



            



            // Next month button



            document.getElementById('nextMonth').addEventListener('click', function() {



                currentMonth++;



                if (currentMonth > 12) {



                    currentMonth = 1;



                    currentYear++;



                }



                loadMonthlyData(currentMonth, currentYear);



            });



        });



        // Discord Webhook Management Functions
        let tokenVisible = false;

        function toggleDropdown() {
            const dropdown = document.getElementById('discordDropdown');
            const arrow = document.getElementById('dropdownArrow');
            
            if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
                arrow.textContent = '‚ñº';
            } else {
                dropdown.classList.add('show');
                arrow.textContent = '‚ñ≤';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('discordDropdown');
            const dropdownBtn = document.querySelector('.dropdown-btn');
            
            if (!dropdownBtn.contains(event.target) && !dropdown.contains(event.target)) {
                dropdown.classList.remove('show');
                document.getElementById('dropdownArrow').textContent = '‚ñº';
            }
        });

        function toggleTokenVisibility() {
            const input = document.getElementById('webhookUrlInput');
            const button = document.getElementById('toggleVisibilityBtn');
            
            if (tokenVisible) {
                input.type = 'password';
                button.textContent = '';
                tokenVisible = false;
            } else {
                input.type = 'text';
                button.textContent = '';
                tokenVisible = true;
            }
        }

        async function loadDiscordWebhook() {
            const statusDiv = document.getElementById('tokenStatus');
            const input = document.getElementById('webhookUrlInput');
            
            try {
                statusDiv.textContent = 'Nalaganje webhook URL...';
                statusDiv.style.color = '#f59e0b';
                
                const response = await fetch('/api/discordToken');
                const data = await response.json();
                
                if (data.discordWebhookUrl) {
                    input.value = data.discordWebhookUrl;
                    statusDiv.textContent = 'Webhook URL nalo≈æen uspe≈°no';
                    statusDiv.style.color = '#10b981';
                } else {
                    statusDiv.textContent = 'Webhook URL ni nastavljen';
                    statusDiv.style.color = '#ef4444';
                }
            } catch (error) {
                statusDiv.textContent = 'Napaka pri nalaganju webhook URL';
                statusDiv.style.color = '#ef4444';
            }
        }

        async function saveDiscordWebhook() {
            const statusDiv = document.getElementById('tokenStatus');
            const input = document.getElementById('webhookUrlInput');
            const webhookUrl = input.value.trim();
            
            if (!webhookUrl) {
                statusDiv.textContent = 'Webhook URL ne sme biti prazen';
                statusDiv.style.color = '#ef4444';
                return;
            }
            
            try {
                statusDiv.textContent = 'Shranjevanje webhook URL...';
                statusDiv.style.color = '#f59e0b';
                
                const response = await fetch('/api/discordToken', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'webhookUrl=' + encodeURIComponent(webhookUrl)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    statusDiv.textContent = 'Webhook URL uspe≈°no shranjen';
                    statusDiv.style.color = '#10b981';
                } else {
                    statusDiv.textContent = 'Napaka: ' + data.message;
                    statusDiv.style.color = '#ef4444';
                }
            } catch (error) {
                statusDiv.textContent = 'Napaka pri shranjevanju webhook URL';
                statusDiv.style.color = '#ef4444';
            }
        }

        // Mini Temperature Chart Functions
        function initializeMiniTempChart(data) {
            console.log('initializeMiniTempChart called with data:', data);
            
            const canvas = document.getElementById('miniTempChart');
            console.log('Canvas element found:', !!canvas);
            
            if (!canvas) {
                console.error('miniTempChart canvas not found!');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            console.log('Canvas context found:', !!ctx);
            
            if (!miniTempChart) {
                console.log('Creating new miniTempChart...');
                try {
                    miniTempChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Temperature',
                                data: [],
                                borderColor: function(context) {
                                    const chart = context.chart;
                                    const {ctx, chartArea} = chart;
                                    if (!chartArea) return '#999999';
                                    
                                    const gradient = ctx.createLinearGradient(chartArea.left, 0, chartArea.right, 0);
                                    gradient.addColorStop(0, 'rgba(153, 153, 153, 0)');    // Fade in at start
                                    gradient.addColorStop(0.15, 'rgba(153, 153, 153, 1)');  // Full opacity
                                    gradient.addColorStop(0.85, 'rgba(153, 153, 153, 1)');  // Full opacity
                                    gradient.addColorStop(1, 'rgba(153, 153, 153, 0)');    // Fade out at end
                                    return gradient;
                                },
                                borderWidth: 2,
                                fill: false,
                                tension: 0.4,
                                pointRadius: 0,
                                pointHoverRadius: 3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false },
                                title: { display: false }
                            },
                            scales: {
                                x: { display: false },
                                y: { display: false }
                            },
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            elements: {
                                point: { radius: 0 }
                            }
                        }
                    });
                    console.log('miniTempChart created successfully');
                } catch (error) {
                    console.error('Error creating miniTempChart:', error);
                    return;
                }
            } else {
                console.log('miniTempChart already exists, updating...');
            }
            
            updateMiniTempChart(data);
        }

        function updateMiniTempChart(data) {
            console.log('updateMiniTempChart called with:', data);
            
            if (!miniTempChart || !data.temps) {
                console.log('Early return - no chart or no temps data');
                return;
            }
            
            // Store data for scrolling
            miniChartData = data;
            
            // Use data directly from mini chart API call
            const temps = data.temps || [];
            const hours = data.hours || [];
            
            console.log('Mini chart data received:', { temps, hours, offset: miniChartOffset });
            console.log('miniTempChart exists:', !!miniTempChart);
            
            miniTempChart.data.labels = hours;
            miniTempChart.data.datasets[0].data = temps;
            
            console.log('Chart data set:', { labels: hours, data: temps });
            
            miniTempChart.update('none'); // Update without animation for smooth scrolling
            
            console.log('Chart updated successfully');
            
            // Update hourly labels positioned close to line
            updateHourlyLabels(hours, temps);
            
            // Update hour labels below graph
            updateHourLabels(hours);
        }

        function updateHourlyLabels(labels, data) {
            const container = document.getElementById('hourlyLabels');
            container.innerHTML = '';
            
            if (!labels || labels.length === 0 || !miniTempChart) return;
            
            const chart = miniTempChart;
            const meta = chart.getDatasetMeta(0);
            const chartArea = chart.chartArea;
            
            if (!meta || !chartArea) return;
            
            labels.forEach((label, index) => {
                if (data[index] !== undefined && data[index] !== null && meta.data[index]) {
                    const point = meta.data[index];
                    const labelDiv = document.createElement('div');
                    
                    // Position label close to the line, above it
                    const yOffset = -25; // 25px above the line
                    const xPos = point.x;
                    const yPos = point.y + yOffset;
                    
                    labelDiv.style.position = 'absolute';
                    labelDiv.style.left = xPos + 'px';
                    labelDiv.style.top = yPos + 'px';
                    labelDiv.style.transform = 'translate(-50%, -50%)';
                    labelDiv.style.fontSize = '15px';
                    labelDiv.style.color = '#999999';
                    labelDiv.style.fontWeight = '400';
                    labelDiv.style.whiteSpace = 'nowrap';
                    labelDiv.style.textShadow = '0 1px 2px rgba(0,0,0,0.8)';
                    labelDiv.textContent = data[index].toFixed(1) + '¬∞';
                    container.appendChild(labelDiv);
                }
            });
        }

        function updateHourLabels(labels) {
            const container = document.getElementById('hourLabels');
            container.innerHTML = '';
            
            console.log('updateHourLabels called with:', labels);
            console.log('miniChartOffset:', miniChartOffset);
            
            if (!labels || labels.length === 0 || !miniTempChart) {
                console.log('No labels or chart available');
                return;
            }
            
            const chart = miniTempChart;
            const meta = chart.getDatasetMeta(0);
            
            if (!meta) {
                console.log('No meta data available');
                return;
            }
            
            console.log('Hour labels array:', labels);
            console.log('Meta data points:', meta.data);
            console.log('Number of labels:', labels.length);
            
            labels.forEach((label, index) => {
                if (label && meta.data[index]) {
                    const point = meta.data[index];
                    const labelDiv = document.createElement('div');
                    
                    // Position label below data point
                    const xPos = point.x;
                    const yPos = 20; // 20px from top of container (below graph)
                    
                    labelDiv.style.position = 'absolute';
                    labelDiv.style.left = xPos + 'px';
                    labelDiv.style.top = yPos + 'px';
                    labelDiv.style.transform = 'translateX(-50%)';
                    labelDiv.style.fontSize = '9px';
                    labelDiv.style.color = '#9ca3af';
                    labelDiv.style.fontWeight = '400';
                    labelDiv.style.whiteSpace = 'nowrap';
                    labelDiv.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';
                    
                    // Format hour if it's a number, otherwise use as-is
                    let hourText = label;
                    if (typeof label === 'number') {
                        hourText = label.toString().padStart(2, '0') + ':00';
                    }
                    
                    labelDiv.textContent = hourText;
                    container.appendChild(labelDiv);
                    
                    console.log(`Hour ${index}: ${hourText} (original: ${label}) at position ${xPos}`);
                } else {
                    console.log(`Skipping hour ${index}: label="${label}", point exists: ${!!meta.data[index]}`);
                }
            });
        }

        function scrollMiniGraph(direction) {
            if (direction === 'left') {
                miniChartOffset = Math.min(miniChartOffset + 1, 12); // Scroll 1 hour back, max 12 hours
            } else {
                miniChartOffset = Math.max(miniChartOffset - 1, 0); // Scroll 1 hour forward
            }
            
            console.log('Scrolling mini graph, offset:', miniChartOffset);
            
            // Fetch fresh data for mini chart separately
            fetchMiniChartData();
        }

        async function fetchMiniChartData() {
            try {
                // Use correct endpoint for Arduino - /api/dayData
                const response = await fetch(`/api/dayData?index=0`);
                const data = await response.json();
                
                if (data && data.temps) {
                    // Apply offset manually to get the right 12-hour range
                    const temps = data.temps || [];
                    const hours = data.hours || [];
                    const startIndex = Math.max(0, temps.length - 12 - miniChartOffset);
                    const endIndex = temps.length - miniChartOffset;
                    
                    const displayData = temps.slice(startIndex, endIndex);
                    const displayHours = hours.slice(startIndex, endIndex);
                    
                    // Create mini chart data object
                    const miniData = {
                        temps: displayData,
                        hours: displayHours
                    };
                    
                    console.log('Mini chart processed data:', { startIndex, endIndex, displayHours, displayData });
                    
                    // Initialize chart first if it doesn't exist
                    if (!miniTempChart) {
                        console.log('Chart does not exist, calling initializeMiniTempChart...');
                        initializeMiniTempChart(miniData);
                    } else {
                        console.log('Chart exists, calling updateMiniTempChart...');
                        updateMiniTempChart(miniData);
                    }
                }
            } catch (error) {
                console.error('Error fetching mini chart data:', error);
            }
        }

        async function fetchHourlyData(index) {
            try {
                const response = await fetch(`/api/hourly_data?index=${index}`);
                const data = await response.json();
                
                if (data && data.temps) {
                    updateMiniTempChart(data);
                }
            } catch (error) {
                console.error('Error fetching hourly data:', error);
            }
        }

        // Load Discord webhook when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded fired');
            loadDiscordWebhook();
            // Initialize mini chart
            console.log('About to call fetchMiniChartData...');
            fetchMiniChartData();
        });


    </script>



</body>



</html>
